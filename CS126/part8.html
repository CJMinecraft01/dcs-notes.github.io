<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/dcs-notes.github.io/assets/js/tocNav.js"></script>

    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/dcs-notes.github.io/assets/css/style.css">
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            <h1 class="project-name">Heaps</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#heaps-adt">Heaps (ADT)</a></li><li><a href="#heap-properties">Heap properties</a><ul><li><a href="#height-of-a-heap">Height of a Heap</a></li></ul></li><li><a href="#heap-methods">Heap methods</a><ul><li><a href="#inserting-into-a-heap">Inserting into a heap</a></li><li><a href="#removal-from-a-heap">Removal from a heap</a></li></ul></li><li><a href="#use-in-sorting">Use in sorting</a></li><li><a href="#concrete-implementations">Concrete implementations</a></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/dcs-notes.github.io/CS126/part7.html" title="Priority queues">üëàPrev</a><a href="./" title="CS126 Home">üè°CS126</a><a href="/dcs-notes.github.io/CS126/part9.html" title="Skip Lists">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h2 id="heaps-adt">Heaps (ADT)</h2>
<blockquote>
  <p><strong>Heaps</strong> are essentially binary trees storing keys at their nodes and satisfying a set of ‚Äúheap properties‚Äù.</p>
</blockquote>

<p>As such, they are implemented in the same way as binary trees, discussed earlier, but with modified internal behaviour when inserting and deleting elements</p>

<h2 id="heap-properties">Heap properties</h2>

<p>The properties a binary tree must fulfil to be a heap are:</p>

<p><strong>Heap-order.</strong> For every internal node other than the root (as it has no parent), the value of the node is greater than the value of the parent node</p>

<p><strong>Complete binary tree.</strong> The height of the tree is minimal for the number of the nodes it contains, and is filled from ‚Äúleft to right‚Äù. This is formally defined as:</p>

<blockquote>
  <p>Let \(h\) be the height of the heap</p>

  <p>‚Äã	Every layer of height \(i\) other than the lowest layer (\(i = h-1\)) has \(2^i\) nodes</p>

  <p>‚Äã	In the lowest layer, the all internal nodes are to the left of external nodes</p>
</blockquote>

<p>The <strong>last node</strong> of the heap is the rightmost node of maximum depth</p>

<p><img src="./images/heapDiagram.png" alt="heapDiagram" class="center" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser</p>

<h3 id="height-of-a-heap">Height of a Heap</h3>

<blockquote>
  <p>A heap storing <strong><em>n</em></strong> keys has height = log<sub>2</sub>n.</p>
</blockquote>

<p><strong>Proof.</strong> Let \(h\) be the height of a heap storing \(n\) keys</p>

<p>Since there are \(2^i\) keys at depth \(i = 0, \ldots, h - 1\) and at least 1 key at depth \(h\), we have \(n \ge 1 +2 +4+\ldots+2^{h-1} + 1\)</p>

<p>Thus, \(n \ge 2^h \Rightarrow h \le log_{2}\ n\).</p>

<h2 id="heap-methods">Heap methods</h2>

<h3 id="inserting-into-a-heap">Inserting into a heap</h3>

<p>First, the element is inserted to its temporary position of the rightmost node of maximum depth, so that it fills from left to right, with a running time of \(O(1)\) time, if a pointer to the position to insert is maintained</p>

<p><img src="./images/heapInsertOne.png" alt="heapInsertOne" class="center" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>Then, the <code class="language-plaintext highlighter-rouge">upheap</code> algorithm is run to re-order the heap so that it fulfils the heap properties. This algorithm repeatedly swaps the inserted node with its parent, until either it reaches the root node, or it is larger than the parent node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let k &lt;- the element to insert
While k is smaller than its parent, and k is not the root node
	Swap the values of k and its parent node
</code></pre></div></div>

<p><img src="./images/heapInsertTwo.png" alt="heapInsertTwo" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>Since the heap has a height of \(O(log_2\ n)\), performing a swap takes \(O(1)\) time, and the maximum number of swaps is the height of the heap, the upheap algorithm takes \(O(log_2\ n)\), time. In total, insertion takes \(O(log_2\ n)\) time.</p>

<h3 id="removal-from-a-heap">Removal from a heap</h3>

<p>The smallest item in the heap is the root node, so this value is stored and returned. However, we need to maintain heap properties as it is overwritten.</p>

<p>First, the value of the root node is overwritten with the value of the last node, and the last node is removed from the tree:</p>

<p><img src="./images/heapRemoveOne.png" class="center" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>Then the <code class="language-plaintext highlighter-rouge">downheap</code> algorithm is run to re-order the heap so that it fulfils the heap properties:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let p &lt;- the root node
Let c &lt;- the child of p with the minimal key (right if existent, otherwise left)
If the value of p is less than or equal to the value of c
	Stop, since the heap order property is fulfilled
Else
	Swap the values of p and c
	Run the downheap algorithm again with the root node (p) now as the child node (c)
</code></pre></div></div>

<p><img src="./images/heapRemoveTwo.png" alt="heapRemoveTwo" /></p>

<p>Image source: <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

<p>As with <code class="language-plaintext highlighter-rouge">upheap</code>, since the heap has a height of \(O(log_2\ n)\), the <code class="language-plaintext highlighter-rouge">downheap</code> algorithm takes \(O(log_2\ n)\) time.</p>

<h2 id="use-in-sorting">Use in sorting</h2>

<p>Since the heap can be used to implement priority queues, it can be used for sorting as with list based implementations, which resulted in selection and insertion sort. This is called a heap sort.</p>

<p>The steps taken in heap sort are:</p>
<ol>
  <li>Enqueue \(n\) elements, with each enqueueing taking \(O(log n)\) time, so the total time is \(O(n \cdot log n)\) time</li>
  <li>Dequeue all \(n\) items, with each Dequeuing taking \(O(log n)\) time, so the total time is \(O(n \cdot log n)\) time</li>
</ol>

<p>Hence, the <strong>overall time complexity</strong> is \(O(n \cdot log n)\)</p>

<p>This is one of the fastest classes of sorting algorithm, and is much more efficient than <strong>quadratic sorting algorithms</strong> like insertion or selection sort.</p>

<h2 id="concrete-implementations">Concrete implementations</h2>

<p>Any <strong>tree implementation</strong> can be used for a heap, as it merely modifies the way getters and setters work, not the internal data structures.</p>

<p>The main draw-back of <strong>array based implementations</strong> of space inefficiency for unbalanced trees is a <strong>non-issue for heaps</strong>, as they are implicitly balanced, so they are often used.</p>


                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>